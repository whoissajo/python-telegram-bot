"""
Cloudinary Commands Module for Telegram Bot
Handles all Cloudinary media management functionality including uploads, listing, and deletion.
"""

import requests
import tempfile
import os
import asyncio
from pyrogram import filters
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from config import logger
from utility_commands import TelegramProgressTracker # Assuming this exists for progress tracking

# Import Cloudinary configurations from config.py
from config import (
    CLOUDINARY_CLOUD_NAME,
    CLOUDINARY_API_KEY,
    CLOUDINARY_API_SECRET,
    CLOUDINARY_FOLDER
)

# Import and configure Cloudinary SDK
try:
    import cloudinary
    import cloudinary.uploader
    import cloudinary.api

    cloudinary.config(
        cloud_name=CLOUDINARY_CLOUD_NAME,
        api_key=CLOUDINARY_API_KEY,
        api_secret=CLOUDINARY_API_SECRET
    )
    cloudinary_configured = True
    logger.info("Cloudinary SDK configured successfully.")
except ImportError:
    cloudinary_configured = False
    logger.error("Cloudinary SDK not found. Please install it: pip install cloudinary")
except Exception as e:
    cloudinary_configured = False
    logger.error(f"Failed to configure Cloudinary: {e}")

# ========== HELPER FUNCTIONS ==========

def get_cloudinary_thumbnail_url(public_id, format="jpg", transformation=None):
    """
    Generates a thumbnail URL for a Cloudinary asset.
    """
    if not cloudinary_configured:
        return None
    
    if transformation is None:
        transformation = {"height": 150, "crop": "limit"} # Default transformation for thumbnail

    # Construct the URL manually based on common Cloudinary URL structure
    # Example: https://res.cloudinary.com/your_cloud_name/image/upload/h_150,c_limit/your_public_id.jpg
    
    # Apply transformation string
    transform_str = ",".join([f"{k}_{v}" for k, v in transformation.items()])
    
    # Public ID might need to include the folder path if not already in it
    # Assuming public_id here is the full path like 'folder/image_name'
    
    url = f"https://res.cloudinary.com/{CLOUDINARY_CLOUD_NAME}/image/upload/{transform_str}/{public_id}.{format}"
    return url

# ========== CLOUDINARY COMMAND HANDLERS ==========

async def handle_cloudinary_upload(client, message: Message):
    """
    Handle .imgup command to upload an image to Cloudinary.
    Expects to be a reply to a photo message.
    """
    if not cloudinary_configured:
        await message.reply("❌ Cloudinary is not configured. Please check the bot logs.")
        return

    reply = message.reply_to_message
    if not reply or not reply.photo:
        await message.reply("⚠️ Please reply to a photo message with `.imgup` or `/imgup` to upload it to Cloudinary.")
        return

    # Use the largest resolution photo available
    photo = reply.photo.file_id
    file_path = None # We will download it to a temp file

    try:
        # Download the photo to a temporary file
        status_msg = await message.reply("📥 Downloading image for Cloudinary upload...")
        
        # Create a temporary file
        temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=".jpg") # Assuming jpg for photos
        file_path = temp_file.name
        temp_file.close()

        # Download the photo
        file_ref = await client.download_media(
            message=reply, # Use the reply message to get the photo
            file_name=file_path,
            progress=None # Can integrate TelegramProgressTracker if needed
        )
        
        if not file_path or not os.path.exists(file_path):
            await status_msg.edit("❌ Failed to download the image.")
            return

        await status_msg.edit(f"⬆️ Uploading image to Cloudinary in folder: `{CLOUDINARY_FOLDER}`...")

        # Upload to Cloudinary
        # Public ID will be generated by Cloudinary if not specified.
        # We specify the folder and a unique public ID (e.g., based on message ID or timestamp)
        # Or let Cloudinary generate it and just specify the folder.
        # Let's use a public ID that includes the folder for better organization if needed.
        # For simplicity, we'll let Cloudinary manage public_ids and just specify the folder.
        
        upload_result = cloudinary.uploader.upload(
            file_path,
            folder=CLOUDINARY_FOLDER,
            resource_type="image",
            public_id=f"media_lib_{reply.message_id}", # Example public_id, could be more robust
            # eager=[{"transformation": {"height": 150, "crop": "limit"}, "format": "jpg"}] # Optional: create eager transformations
        )

        if upload_result and upload_result.get("secure_url"):
            embed_link = upload_result.get("secure_url")

            response_text = (
                f"✅ Image uploaded successfully!\n\n"
                f"**Embed Link:**\n{embed_link}"
            )
            await status_msg.edit(response_text)
        else:
            await status_msg.edit("❌ Upload to Cloudinary failed. Please check logs or try again.")

    except Exception as e:
        logger.error(f"Error during Cloudinary upload: {e}")
        await message.reply(f"❌ An error occurred during upload: {e}")
    finally:
        # Clean up the temporary file
        if file_path and os.path.exists(file_path):
            os.unlink(file_path)

async def handle_list_images(client, message: Message):
    """
    Handle .imgs command to list images from Cloudinary folder.
    """
    if not cloudinary_configured:
        await message.reply("❌ Cloudinary is not configured. Please check the bot logs.")
        return

    try:
        await message.reply("🔍 Fetching images from Cloudinary...")
        
        # List resources in the specified folder
        # We might need to paginate if there are many images
        list_result = cloudinary.api.resources(
            type="upload",
            prefix=CLOUDINARY_FOLDER,
            max_results=25 # Fetch up to 25 images initially
        )
        
        resources = list_result.get("resources", [])

        if not resources:
            await message.reply("❌ No images found in the specified Cloudinary folder.")
            return

        # Create inline keyboard for the images
        keyboard = create_image_keyboard(resources, page=0)
        
        # Send the first page of images
        await message.reply(
            "🖼️ **Cloudinary Media Library**\n\n"
            "Select an image to view or manage:",
            reply_markup=keyboard
        )

    except Exception as e:
        logger.error(f"Error listing Cloudinary images: {e}")
        await message.reply(f"❌ An error occurred while fetching images: {e}")


# ========== CALLBACK HANDLERS ==========

def create_image_keyboard(resources, page=0, per_page=5):
    """
    Create inline keyboard for images list.
    """
    keyboard = []
    start_idx = page * per_page
    end_idx = start_idx + per_page
    page_resources = resources[start_idx:end_idx]
    
    for resource in page_resources:
        public_id = resource["public_id"]
        asset_type = resource["resource_type"] # 'image', 'video', etc.
        format = resource["format"]
        
        # Create a unique callback data for each image, including its public_id
        # Use 'img_view_{public_id}' to view details/thumbnail
        callback_data = f"img_view_{public_id}"
        
        # Button text can be the public ID or a snippet of it
        button_text = f"{public_id.split('/')[-1][:20]}... ({format})"
        
        keyboard.append([InlineKeyboardButton(
            button_text, 
            callback_data=callback_data
        )])
    
    # Pagination buttons
    nav_buttons = []
    if page > 0:
        nav_buttons.append(InlineKeyboardButton("⬅️ Previous", callback_data=f"img_page_{page-1}"))
    if end_idx < len(resources):
        nav_buttons.append(InlineKeyboardButton("Next ➡️", callback_data=f"img_page_{page+1}"))
    
    if nav_buttons:
        keyboard.append(nav_buttons)
    
    # Add a refresh button
    keyboard.append([InlineKeyboardButton("🔄 Refresh", callback_data="img_refresh")])
    
    return InlineKeyboardMarkup(keyboard)

async def handle_image_callback(client, callback_query: CallbackQuery):
    """
    Handle all callback queries related to images.
    """
    data = callback_query.data
    message = callback_query.message

    if data.startswith("img_view_"):
        # View details for a specific image
        public_id = data.replace("img_view_", "")
        await show_image_details(client, callback_query, public_id)

    elif data.startswith("img_page_"):
        # Navigate pages for the image list
        page = int(data.replace("img_page_", ""))
        # Need to refetch resources to display correct page
        # This requires storing resources or re-fetching them. Re-fetching is simpler for now.
        await refresh_image_list(client, callback_query, page=page)

    elif data == "img_refresh":
        # Refresh the current image list view
        await refresh_image_list(client, callback_query)

    elif data.startswith("img_delete_"):
        # Delete an image
        public_id = data.replace("img_delete_", "")
        await delete_cloudinary_image(client, callback_query, public_id)
    
    elif data == "img_back":
        # Go back to the image list
        await go_back_to_image_list(client, callback_query)

    await callback_query.answer() # Acknowledge the callback


async def show_image_details(client, callback_query: CallbackQuery, public_id: str):
    """
    Show thumbnail and details for a specific image, with delete/back buttons.
    """
    try:
        # Get resource info to get format and other details
        resource_info = cloudinary.api.resource(public_id)
        
        if not resource_info:
            await callback_query.message.edit_text("❌ Could not retrieve image details.")
            return

        image_format = resource_info.get("format", "jpg")
        # For thumbnail, let's use a default transformation
        thumbnail_url = get_cloudinary_thumbnail_url(public_id, format=image_format)
        
        # Construct a more embeddable URL or a direct link
        direct_link = f"https://res.cloudinary.com/{CLOUDINARY_CLOUD_NAME}/image/upload/{public_id}.{image_format}"

        # Create detail-specific keyboard
        detail_keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("🗑️ Delete", callback_data=f"img_delete_{public_id}")
            ],
            [
                InlineKeyboardButton("⬅️ Back", callback_data="img_back")
            ]
        ])

        caption_text = (
            f"🖼️ **Image Details**\n\n"
            f"🆔 Public ID: `{public_id}`\n"
            f"🆔 Format: {image_format.upper()}\n"
            f"🔗 Direct Link: {direct_link}\n"
            f"🌐 Embed Link: {thumbnail_url}"
        )

        # If message is a photo, edit it. Otherwise, send a new photo.
        if callback_query.message.photo:
            await callback_query.message.edit_photo(
                photo=thumbnail_url,
                caption=caption_text,
                reply_markup=detail_keyboard
            )
        else:
            await callback_query.message.delete() # Delete previous text message
            await client.send_photo(
                chat_id=callback_query.message.chat.id,
                photo=thumbnail_url,
                caption=caption_text,
                reply_markup=detail_keyboard
            )

    except Exception as e:
        logger.error(f"Error showing image details for {public_id}: {e}")
        await callback_query.message.edit_text(f"❌ Error loading image details: {e}")


async def delete_cloudinary_image(client, callback_query: CallbackQuery, public_id: str):
    """
    Deletes an image from Cloudinary.
    """
    try:
        delete_result = cloudinary.uploader.destroy(public_id, invalidate=True)
        
        if delete_result and delete_result.get("result") == "ok":
            await callback_query.message.edit_text(f"✅ Image `{public_id.split('/')[-1]}` deleted successfully.")
            # Optionally, go back to the list automatically or leave the confirmation message
            await asyncio.sleep(2) # Show confirmation for a bit
            await go_back_to_image_list(client, callback_query) # Go back to list
        else:
            await callback_query.message.edit_text(f"❌ Failed to delete image `{public_id.split('/')[-1]}`.")
            
    except Exception as e:
        logger.error(f"Error deleting Cloudinary image {public_id}: {e}")
        await callback_query.message.edit_text(f"❌ Error deleting image: {e}")


async def refresh_image_list(client, callback_query: CallbackQuery, page=0):
    """
    Refreshes the list of images, potentially for pagination.
    """
    try:
        list_result = cloudinary.api.resources(
            type="upload",
            prefix=CLOUDINARY_FOLDER,
            max_results=25 # Fetch up to 25 images
        )
        resources = list_result.get("resources", [])

        if not resources:
            await callback_query.message.edit_text("❌ No images found in the specified Cloudinary folder.")
            return

        keyboard = create_image_keyboard(resources, page=page)
        
        await callback_query.message.edit_text(
            "🖼️ **Cloudinary Media Library**\n\n"
            "Select an image to view or manage:",
            reply_markup=keyboard
        )
        await callback_query.answer("List refreshed!")

    except Exception as e:
        logger.error(f"Error refreshing image list: {e}")
        await callback_query.message.edit_text(f"❌ Error refreshing list: {e}")
        await callback_query.answer("Error refreshing list")


async def go_back_to_image_list(client, callback_query: CallbackQuery):
    """
    Navigates back to the main image list view.
    """
    try:
        list_result = cloudinary.api.resources(
            type="upload",
            prefix=CLOUDINARY_FOLDER,
            max_results=25 # Fetch up to 25 images
        )
        resources = list_result.get("resources", [])

        if not resources:
            await callback_query.message.edit_text("❌ No images found in the specified Cloudinary folder.")
            return

        keyboard = create_image_keyboard(resources) # Default to first page
        
        # Edit the current message to show the list again
        await callback_query.message.edit_text(
            "🖼️ **Cloudinary Media Library**\n\n"
            "Select an image to view or manage:",
            reply_markup=keyboard
        )
        await callback_query.answer()

    except Exception as e:
        logger.error(f"Error going back to image list: {e}")
        await callback_query.message.edit_text(f"❌ Error going back to list: {e}")
        await callback_query.answer("Error going back")


# ========== REGISTER CLOUDINARY COMMANDS ==========

def register_cloudinary_commands(app):
    """
    Register all Cloudinary-related commands with the bot.
    """
    
    # Check if Cloudinary is configured before registering
    if not cloudinary_configured:
        logger.warning("Skipping Cloudinary command registration due to configuration failure.")
        return

    # Command for uploading an image
    @app.on_message(filters.regex(r'^[./]imgup') & filters.reply)
    async def imgup_command(client, message: Message):
        """Handle .imgup or /imgup command"""
        await handle_cloudinary_upload(client, message)
    
    # Command for listing images
    @app.on_message(filters.regex(r'^[./]imgs$'))
    async def imgs_command(client, message: Message):
        """Handle .imgs or /imgs command"""
        await handle_list_images(client, message)
    
    # Callback handler for all Cloudinary image actions
    @app.on_callback_query(filters.regex(r'^img_'))
    async def cloudinary_callback_handler(client, callback_query: CallbackQuery):
        """Handle all Cloudinary image-related callback queries"""
        await handle_image_callback(client, callback_query)

    logger.info("Cloudinary commands registered successfully.")